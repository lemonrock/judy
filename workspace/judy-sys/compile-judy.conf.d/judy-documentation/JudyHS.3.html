<!-- Creator     : groff version 1.19.2 -->
<!-- CreationDate: Wed Jul 19 12:44:45 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p     { margin-top: 0; margin-bottom: 0; }
       pre   { margin-top: 0; margin-bottom: 0; }
       table { margin-top: 0; margin-bottom: 0; }
</style>
<title>JudyHS</title>

</head>
<body>

<h1 align=center>JudyHS</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#JHSI(PValue, PJHSArray, Index, Length) // JudyHSIns()">JHSI(PValue, PJHSArray, Index, Length) // JudyHSIns()</a><br>
<a href="#JHSD(Rc_int, PJHSArray, Index, Length) // JudyHSDel()">JHSD(Rc_int, PJHSArray, Index, Length) // JudyHSDel()</a><br>
<a href="#JHSG(PValue, PJHSArray, Index, Length) // JudyHSGet()">JHSG(PValue, PJHSArray, Index, Length) // JudyHSGet()</a><br>
<a href="#JHSFA(Rc_word, PJHSArray) // JudyHSFreeArray()">JHSFA(Rc_word, PJHSArray) // JudyHSFreeArray()</a><br>
<a href="#ERRORS: See: Judy_3.htm#ERRORS">ERRORS: See: Judy_3.htm#ERRORS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<a name="NAME"></a>
<h2>NAME</h2>


<p style="margin-left:11%; margin-top: 1em">JudyHS macros -
C library for creating and accessing a dynamic array, using
an array-of-bytes of <b>Length</b> as an <b>Index</b> and a
word as a <b>Value</b>.</p>

<a name="SYNOPSIS"></a>
<h2>SYNOPSIS</h2>


<p style="margin-left:11%; margin-top: 1em"><b><big>cc
[flags]</big></b> <big><i>sourcefiles</i>
<b>-lJudy</b></big></p>

<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;Judy.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Word_t *
PValue; // JudyHS array element <br>
int Rc_int; // return flag <br>
Word_t Rc_word; // full word return value <br>
Pvoid_t PJHSArray = (Pvoid_t) NULL; // initialize JudyHS
array <br>
uint8_t * Index; // array-of-bytes pointer <br>
Word_t Length; // number of bytes in Index</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>JHSI(
PValue, PJHSArray, Index, Length); // JudyHSIns() <br>
JHSD( Rc_int, PJHSArray, Index, Length); // JudyHSDel() <br>
JHSG( PValue, PJHSArray, Index, Length); // JudyHSGet() <br>
JHSFA(Rc_word, PJHSArray); // JudyHSFreeArray()</b></p>

<a name="DESCRIPTION"></a>
<h2>DESCRIPTION</h2>


<p style="margin-left:11%; margin-top: 1em">A JudyHS array
is the equivalent of an array of word-sized value/pointers.
An <b>Index</b> is a pointer to an array-of-bytes of
specified length: <b>Length</b>. Rather than using a null
terminated string, this difference from <i>JudySL</i>(3)
allows strings to contain all bits (specifically the null
character). This new addition (May 2004) to Judy arrays is a
hybird using the best capabilities of hashing and Judy
methods. <b>JudyHS</b> does not have a poor performance case
where knowledge of the hash algorithm can be used to degrade
the performance.</p>

<p style="margin-left:11%; margin-top: 1em">Since JudyHS is
based on a hash method, <b>Indexes</b> are not stored in any
particular order. Therefore the JudyHSFirst(), JudyHSNext(),
JudyHSPrev() and JudyHSLast() neighbor search functions are
not practical. The <b>Length</b> of each array-of-bytes can
be from 0 to the limits of <i>malloc()</i> (about 2GB).</p>

<p style="margin-left:11%; margin-top: 1em">The hallmark of
<b>JudyHS</b> is speed with scalability, but memory
efficiency is excellent. The speed is very competitive with
the best hashing methods. The memory efficiency is similar
to a linked list of the same <b>Indexes</b> and
<b>Values</b>. <b>JudyHS</b> is designed to scale from 0 to
billions of <b>Indexes</b>.</p>

<p style="margin-left:11%; margin-top: 1em">A JudyHS array
is allocated with a <b>NULL</b> pointer</p>

<p style="margin-left:11%; margin-top: 1em"><big>Pvoid_t
PJHSArray = (Pvoid_t) NULL;</big></p>

<p style="margin-left:11%; margin-top: 1em">Because the
macro forms of the API have a simpler error handling
interface than the equivalent <i>functions</i>, they are the
preferred way to use JudyHS.</p>

<a name="JHSI(PValue, PJHSArray, Index, Length) // JudyHSIns()"></a>
<h2>JHSI(PValue, PJHSArray, Index, Length) // JudyHSIns()</h2>


<p style="margin-left:11%; margin-top: 1em">Given a pointer
to a JudyHS array (<b>PJHSArray</b>), insert an <b>Index</b>
string of length: <b>Length</b> and a <b>Value</b> into the
JudyHS array: <b>PJHSArray</b>. If the <b>Index</b> is
successfully inserted, the <b>Value</b> is initialized to 0.
If the <b>Index</b> was already present, the <b>Value</b> is
not modified.</p>

<p style="margin-left:11%; margin-top: 1em">Return
<b>PValue</b> pointing to <b>Value</b>. Your program should
use this pointer to read or modify the <b>Value</b>, for
example:</p>

<p style="margin-left:11%; margin-top: 1em"><big>Value =
*PValue; <br>
*PValue = 1234;</big></p>

<p style="margin-left:11%; margin-top: 1em"><b>Note</b>:
<b>JHSI()</b> and <b>JHSD</b> can reorganize the JudyHS
array. Therefore, pointers returned from previous
<b>JudyHS</b> calls become invalid and must be re-acquired
(using <b>JHSG()</b>).</p>

<a name="JHSD(Rc_int, PJHSArray, Index, Length) // JudyHSDel()"></a>
<h2>JHSD(Rc_int, PJHSArray, Index, Length) // JudyHSDel()</h2>


<p style="margin-left:11%; margin-top: 1em">Given a pointer
to a JudyHS array (<b>PJHSArray</b>), delete the specified
<b>Index</b> along with the <b>Value</b> from the JudyHS
array.</p>

<p style="margin-left:11%; margin-top: 1em">Return
<b>Rc_int</b> set to 1 if successfully removed from the
array. Return <b>Rc_int</b> set to 0 if <b>Index</b> was not
present.</p>

<a name="JHSG(PValue, PJHSArray, Index, Length) // JudyHSGet()"></a>
<h2>JHSG(PValue, PJHSArray, Index, Length) // JudyHSGet()</h2>


<p style="margin-left:11%; margin-top: 1em">Given a pointer
to a JudyHS array (<b>PJHSArray</b>), find <b>Value</b>
associated with <b>Index</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Return
<b>PValue</b> pointing to <b>Index</b>&rsquo;s <b>Value</b>.
Return <b>PValue</b> set to <b>NULL</b> if the <b>Index</b>
was not present.</p>

<a name="JHSFA(Rc_word, PJHSArray) // JudyHSFreeArray()"></a>
<h2>JHSFA(Rc_word, PJHSArray) // JudyHSFreeArray()</h2>


<p style="margin-left:11%; margin-top: 1em">Given a pointer
to a JudyHS array (<b>PJHSArray</b>), free the entire
array.</p>

<p style="margin-left:11%; margin-top: 1em">Return
<b>Rc_word</b> set to the number of bytes freed and
<b>PJHSArray</b> set to NULL.</p>

<a name="ERRORS: See: Judy_3.htm#ERRORS"></a>
<h2>ERRORS: See: Judy_3.htm#ERRORS</h2>


<a name="EXAMPLES"></a>
<h2>EXAMPLES</h2>


<p style="margin-left:11%; margin-top: 1em">Show how to
program with the JudyHS macros. This program will print
duplicate lines and their line number from <i>stdin</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><big>#include
&lt;unistd.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;string.h&gt; <br>
#include &lt;Judy.h&gt;</big></p>

<p style="margin-left:11%; margin-top: 1em">// Compiled:
<br>
// cc -O PrintDupLines.c -lJudy -o PrintDupLines</p>

<p style="margin-left:11%; margin-top: 1em">#define MAXLINE
1000000 /* max fgets length of line */ <br>
uint8_t Index[MAXLINE]; // string to check</p>

<p style="margin-left:11%; margin-top: 1em">int // Usage:
PrintDupLines &lt; file <br>
main() <br>
{ <br>
Pvoid_t PJArray = (PWord_t)NULL; // Judy array. <br>
PWord_t PValue; // Judy array element pointer. <br>
Word_t Bytes; // size of JudyHS array. <br>
Word_t LineNumb = 0; // current line number <br>
Word_t Dups = 0; // number of duplicate lines</p>

<p style="margin-left:11%; margin-top: 1em">while
(fgets(Index, MAXLINE, stdin) != (char *)NULL) <br>
{ <br>
LineNumb++; // line number</p>

<p style="margin-left:11%; margin-top: 1em">// store string
into array <br>
JHSI(PValue, PJArray, Index, strlen(Index)); <br>
if (PValue == PJERR) // See ERRORS section <br>
{ <br>
fprintf(stderr, &quot;Out of memory -- exit\n&quot;); <br>
exit(1); <br>
} <br>
if (*PValue == 0) // check if duplicate <br>
{ <br>
Dups++; <br>
printf(&quot;Duplicate lines %lu:%lu:%s&quot;, *PValue,
LineNumb, Index); <br>
} <br>
else <br>
{ <br>
*PValue = LineNumb; // store Line number <br>
} <br>
} <br>
printf(&quot;%lu Duplicates, free JudyHS array of %lu
Lines\n&quot;, <br>
Dups, LineNumb - Dups); <br>
JHSFA(Bytes, PJArray); // free JudyHS array <br>
printf(&quot;JudyHSFreeArray() free&rsquo;ed %lu bytes of
memory\n&quot;, Bytes); <br>
return (0); <br>
}</p>

<a name="AUTHOR"></a>
<h2>AUTHOR</h2>


<p style="margin-left:11%; margin-top: 1em">JudyHS was
invented and implemented by Doug Baskins after retiring from
Hewlett-Packard.</p>

<a name="SEE ALSO"></a>
<h2>SEE ALSO</h2>



<p style="margin-left:11%; margin-top: 1em"><i>Judy</i>(3),
<i>Judy1</i>(3), <i>JudyL</i>(3), <i>JudySL</i>(3), <i><br>
malloc()</i>, <br>
the Judy website, <i>http://judy.sourceforge.net</i>, for
further information and Application Notes.</p>
<hr>
</body>
</html>
