<!-- Creator     : groff version 1.19.2 -->
<!-- CreationDate: Wed Jul 19 12:44:42 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p     { margin-top: 0; margin-bottom: 0; }
       pre   { margin-top: 0; margin-bottom: 0; }
       table { margin-top: 0; margin-bottom: 0; }
</style>
<title>JudyL</title>

</head>
<body>

<h1 align=center>JudyL</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#Multi-dimensional JudyL Arrays">Multi-dimensional JudyL Arrays</a><br>
<a href="#ERRORS: See: Judy_3.htm#ERRORS">ERRORS: See: Judy_3.htm#ERRORS</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<a name="NAME"></a>
<h2>NAME</h2>


<p style="margin-left:11%; margin-top: 1em">JudyL macros -
C library for creating and accessing a dynamic array of
words, using a word as an index.</p>

<a name="SYNOPSIS"></a>
<h2>SYNOPSIS</h2>


<p style="margin-left:11%; margin-top: 1em"><b><big>cc
[flags]</big></b> <big><i>sourcefiles</i>
<b>-lJudy</b></big></p>

<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;Judy.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int Rc_int;
// return code - integer <br>
Word_t Rc_word; // return code - unsigned word <br>
Word_t Index, Index1, Index2, Nth; <br>
PWord_t PValue; // pointer to return value <br>
Pvoid_t PJLArray = (Pvoid_t) NULL; // initialize JudyL
array</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>JLI( PValue,
PJLArray, Index); // JudyLIns() <br>
JLD( Rc_int, PJLArray, Index); // JudyLDel() <br>
JLG( PValue, PJLArray, Index); // JudyLGet() <br>
JLC( Rc_word, PJLArray, Index1, Index2); // JudyLCount()
<br>
JLBC(PValue, PJLArray, Nth, Index); // JudyLByCount() <br>
JLFA(Rc_word, PJLArray); // JudyLFreeArray() <br>
JLMU(Rc_word, PJLArray); // JudyLMemUsed() <br>
JLF( PValue, PJLArray, Index); // JudyLFirst() <br>
JLN( PValue, PJLArray, Index); // JudyLNext() <br>
JLL( PValue, PJLArray, Index); // JudyLLast() <br>
JLP( PValue, PJLArray, Index); // JudyLPrev() <br>
JLFE(Rc_int, PJLArray, Index); // JudyLFirstEmpty() <br>
JLNE(Rc_int, PJLArray, Index); // JudyLNextEmpty() <br>
JLLE(Rc_int, PJLArray, Index); // JudyLLastEmpty() <br>
JLPE(Rc_int, PJLArray, Index); // JudyLPrevEmpty()</b></p>

<a name="DESCRIPTION"></a>
<h2>DESCRIPTION</h2>


<p style="margin-left:11%; margin-top: 1em">A JudyL array
is the equivalent of an array of word-sized values. A
<b>Value</b> is addressed by an <b>Index</b> (key). The
array may be sparse, and the <b>Index</b> may be any
word-sized number. Memory to support the array is allocated
as index/value pairs are inserted, and released as
index/value pairs are deleted. A JudyL array can also be
thought of as a mapper, that is &quot;map&quot; a word to
another word/pointer.</p>

<p style="margin-left:11%; margin-top: 1em">As with an
ordinary array, there are no duplicate indexes in a JudyL
array.</p>

<p style="margin-left:11%; margin-top: 1em">The value may
be used as a scalar, or a pointer to a structure or block of
data (or even another Judy array).</p>

<p style="margin-left:11%; margin-top: 1em">A JudyL array
is allocated with a <b>NULL</b> pointer</p>

<p style="margin-left:11%; margin-top: 1em"><big>Pvoid_t
PJLArray = (Pvoid_t) NULL;</big></p>

<p style="margin-left:11%; margin-top: 1em">Using the
macros described here, rather than the <b>JudyL function
calls</b>, the default error handling sends a message to the
standard error and terminates the program with
<i>exit(1);</i>. For other error handling methods, see the
<i>ERRORS</i> section. <i>JLI</i>( PValue, PJLArray, Index);
// <b>JudyLIns()</b></p>

<p style="margin-left:11%; margin-top: 1em">Because the
macro forms are sometimes faster and have a simpler error
handling interface than the equivalent <b>JudyL
functions</b>, they are the preferred way of calling the
JudyL functions. <b><br>
JLI(PValue, PJLArray, Index)</b> // <b>JudyLIns()</b></p>

<p style="margin-left:34%;">Insert an <b>Index</b> and
<b>Value</b> into the JudyL array <b>PJLArray</b>. If the
<b>Index</b> is successfully inserted, the <b>Value</b> is
initialized to 0. If the <b>Index</b> was already present,
the <b>Value</b> is not modified.</p>

<p style="margin-left:34%; margin-top: 1em">Return
<b>PValue</b> pointing to <b>Value</b>. Your program can use
this pointer to read or modify <b>Value</b> until the next
<b>JLI()</b> (insert), <b>JLD()</b> (delete) or
<b>JLFA()</b> (freearray) is executed on <b>PJLArray</b>.
Examples:</p>

<p style="margin-left:34%; margin-top: 1em"><big>*PValue =
1234; <br>
Value = *PValue;</big></p>

<p style="margin-left:34%; margin-top: 1em">Return
<b>PValue</b> set to <b>PJERR</b> if a <i>malloc()</i> fail
occured. <b>Note</b>: <b>JLI()</b> and <b>JLD()</b>
reorganize the JudyL array. Therefore, <b>PValue</b>
returned from previous <b>JudyL</b> calls become invalid and
must be re-acquired.</p>

<p style="margin-left:11%;"><b>JLD(Rc_int, PJLArray,
Index)</b> // <b>JudyLDel()</b></p>

<p style="margin-left:34%;">Delete the
<b>Index</b>/<b>Value</b> pair from the JudyL array.</p>

<p style="margin-left:34%; margin-top: 1em">Return
<b>Rc_int</b> set to 1 if successful. Return <b>Rc_int</b>
set to 0 if <b>Index</b> was not present. Return
<b>Rc_int</b> set to <b>JERR</b> if a <i>malloc()</i> fail
occured.</p>

<p style="margin-left:11%;"><b>JLG(PValue, PJLArray,
Index)</b> // <b>JudyLGet()</b></p>

<p style="margin-left:34%;">Get the pointer <b>PValue</b>
associated with <b>Index</b> in the <b>PJLArray</b> Judy
array.</p>

<p style="margin-left:34%; margin-top: 1em">Return
<b>PValue</b> pointing to <b>Value</b>. Return <b>PValue</b>
set to <b>NULL</b> if the <b>Index</b> was not present.
Return <b>PValue</b> set to <b>PJERR</b> if a
<i>malloc()</i> fail occured.</p>

<p style="margin-left:11%;"><b>JLC(Rc_word, PJLArray,
Index1, Index2)</b> // <b>JudyLCount()</b></p>

<p style="margin-left:34%;">Count the number of indexes
present in the JudyL array <b>PJLArray</b> between
<b>Index1</b> and <b>Index2</b> (inclusive).</p>

<p style="margin-left:34%; margin-top: 1em">Return
<b>Rc_word</b> set to the count. A return value of 0 can be
valid as a count.</p>

<p style="margin-left:34%; margin-top: 1em">To count all
indexes present in a JudyL array, use:</p>


<p style="margin-left:34%; margin-top: 1em"><big>JLC(Rc_word,
PJLArray, 0, -1);</big></p>

<p style="margin-left:11%;"><b>JLBC(PValue, PJLArray, Nth,
Index)</b> // <b>JudyLByCount()</b></p>

<p style="margin-left:34%;">Locate the <b>Nth</b> index
that is present in the JudyL array <b>PJLArray</b>
(<b>Nth</b> = 1 returns the first index present).</p>

<p style="margin-left:34%; margin-top: 1em">Return
<b>PValue</b> pointing to its <b>Value</b> and <b>Index</b>
set to the <b>Nth</b> index if found, otherwise return
<b>PValue</b> set to <b>NULL</b> (the value of <b>Index</b>
is undefined).</p>

<p style="margin-left:11%;"><b>JLFA(Rc_word, PJLArray)</b>
// <b>JudyLFreeArray()</b></p>

<p style="margin-left:34%;">Given a pointer to a JudyL
array, free the entire array (much faster than using a
<b>JLN()</b>, <b>JLD()</b> loop).</p>

<p style="margin-left:34%; margin-top: 1em">Return
<b>Rc_word</b> set to the number of bytes freed and
<b>PJLArray</b> set to <b>NULL</b>.</p>

<p style="margin-left:11%;"><b>JLMU(Rc_word, PJLArray)</b>
// <b>JudyLMemUsed()</b></p>

<p style="margin-left:34%;">Return <b>Rc_word</b> set to
the number of bytes of memory <i>malloc()</i>&rsquo;ed by
<b>PJLArray</b>. This is a very fast routine, and may be
used before and after a <b>JLI()</b> or <b>JLD()</b> call
with little performance impact.</p>

<p style="margin-left:11%;"><b>JudyL Search
Functions</b></p>

<p style="margin-left:34%;"><b>JLF()</b>, <b>JLN()</b>,
<b>JLL()</b>, <b>JLP()</b> allow you to search for indexes
in the array. You may search inclusively or exclusively, in
either forward or reverse directions. If successful,
<b>Index</b> is returned set to the found index, and
<b>PValue</b> is returned set to a pointer to
<b>Index</b>&rsquo;s <b>Value</b>. If unsuccessful,
<b>PValue</b> is returned set to <b>NULL</b>, and
<b>Index</b> contains no useful information. <b>PValue</b>
must be tested for non-<b>NULL</b> prior to using
<b>Index</b>, since a search failure is possible.</p>

<p style="margin-left:34%; margin-top: 1em"><b>JLFE()</b>,
<b>JLNE()</b>, <b>JLLE()</b>, <b>JLPE()</b> allow you to
search for indexes that are not present (&quot;empty&quot;)
in the array. You may search inclusively or exclusively, in
either forward or reverse directions. If successful,
<b>Index</b> is returned set to a not present
(&quot;empty&quot;) index, and <b>Rc_int</b> is returned set
to 1. If unsuccessful, <b>Rc_int</b> is returned set to 0,
and and <b>Index</b> contains no useful information.
<b>Rc_int</b> must be checked prior to using <b>Index</b>,
since a search failure is possible.</p>

<p style="margin-left:11%;"><b>JLF(PValue, PJLArray,
Index)</b> // <b>JudyLFirst()</b></p>

<p style="margin-left:34%;">Search (inclusive) for the
first index present that is equal to or greater than the
passed <b>Index</b>. (Start with <b>Index</b> = 0 to find
the first index in the array.) <b>JLF()</b> is typically
used to <i>begin</i> a sorted-order scan of the indexes
present in a JudyL array.</p>

<p style="margin-left:11%;"><b>JLN(PValue, PJLArray,
Index)</b> // <b>JudyLNext()</b></p>

<p style="margin-left:34%;">Search (exclusive) for the next
index present that is greater than the passed <b>Index</b>.
<b>JLN()</b> is typically used to <i>continue</i> a
sorted-order scan of the indexes present in a JudyL array,
or to locate a &quot;neighbor&quot; of a given index.</p>

<p style="margin-left:11%;"><b>JLL(PValue, PJLArray,
Index)</b> // <b>JudyLLast()</b></p>

<p style="margin-left:34%;">Search (inclusive) for the last
index present that is equal to or less than the passed
<b>Index</b>. (Start with <b>Index</b> = -1, that is, all
ones, to find the last index in the array.) <b>JLL()</b> is
typically used to <i>begin</i> a reverse-sorted-order scan
of the indexes present in a JudyL array.</p>

<p style="margin-left:11%;"><b>JLP(PValue, PJLArray,
Index)</b> // <b>JudyLPrev()</b></p>

<p style="margin-left:34%;">Search (exclusive) for the
previous index present that is less than the passed
<b>Index</b>. <b>JLP()</b> is typically used to
<i>continue</i> a reverse-sorted-order scan of the indexes
present in a JudyL array, or to locate a
&quot;neighbor&quot; of a given index.</p>

<p style="margin-left:11%;"><b>JLFE(Rc_int, PJLArray,
Index)</b> // <b>JudyLFirstEmpty()</b></p>

<p style="margin-left:34%;">Search (inclusive) for the
first index absent that is equal to or greater than the
passed <b>Index</b>. (Start with <b>Index</b> = 0 to find
the first index absent in the array.)</p>

<p style="margin-left:11%;"><b>JLNE(Rc_int, PJLArray,
Index)</b> // <b>JudyLNextEmpty()</b></p>

<p style="margin-left:34%;">Search (exclusive) for the next
index absent that is greater than the passed
<b>Index</b>.</p>

<p style="margin-left:11%;"><b>JLLE(Rc_int, PJLArray,
Index)</b> // <b>JudyLLastEmpty()</b></p>

<p style="margin-left:34%;">Search (inclusive) for the last
index absent that is equal to or less than the passed
<b>Index</b>. (Start with <b>Index</b> = -1, that is, all
ones, to find the last index absent in the array.)</p>

<p style="margin-left:11%;"><b>JLPE(Rc_int, PJLArray,
Index)</b> // <b>JudyLPrevEmpty()</b></p>

<p style="margin-left:34%;">Search (exclusive) for the
previous index absent that is less than the passed
<b>Index</b>.</p>

<a name="Multi-dimensional JudyL Arrays"></a>
<h2>Multi-dimensional JudyL Arrays</h2>


<p style="margin-left:11%; margin-top: 1em">Storing a
pointer to another JudyL array in a JudyL array&rsquo;s
<b>Value</b> is a simple way to support dynamic
multi-dimensional arrays. These arrays (or trees) built
using JudyL arrays are very fast and memory efficient. (In
fact, that is how JudySL and JudyHS are implemented). An
arbitrary number of dimensions can be realized this way. To
terminate the number of dimensions (or tree), the
<b>Value</b> pointer is marked to <b>NOT</b> point to
another Judy array. A <b>JLAP_INVALID</b> flag is used in
the least significant bit(s) of the pointer. After the flag
<b>JLAP_INVALID</b> is removed, it is used as a pointer to
the users data. The <b>Judy.h</b> header file defines
<b>JLAP_INVALID</b>. See code fragment below.</p>

<p style="margin-left:11%; margin-top: 1em">Note: The
current version of <b>Judy.h</b> changed this flag from 0x4
to 0x1 to allow for a <i>malloc()</i> that does not deliver
memory on an 8 byte aligned boundry (such as old versions of
valgrind).</p>

<p style="margin-left:11%; margin-top: 1em">The following
example code segment can be used to determine whether or not
a pointer points to another JudyL:</p>

<p style="margin-left:11%; margin-top: 1em"><big>PValue =
(PWord_t)PMultiDimArray;</big></p>

<p style="margin-left:11%; margin-top: 1em">for (Dim = 0;
;Dim++) <br>
{ <br>
if (PValue == (PWord_t)NULL) goto IndexNotFound;</p>

<p style="margin-left:11%; margin-top: 1em">/* Advance to
next dimension in array */ <br>
JLG(PValue, (Pvoid_t)*PValue, Index[Dim]);</p>

<p style="margin-left:11%; margin-top: 1em">/* Check if
pointer to user buffer: */ <br>
if (*PValue &amp; JLAP_INVALID)) break; <br>
} <br>
UPointer = (UPointer_t) (*PValue &amp; ~JLAP_INVALID); //
mask and cast. <br>
printf(&quot;User object pointer is 0x%lx\n&quot;, (Word_t)
UPointer); <br>
...</p>

<p style="margin-left:11%; margin-top: 1em">Note: This
works because <i>malloc()</i> guarantees to return a pointer
with the least bit(s) == 0x0. You must remove
<b>JLAP_INVALID</b> before using the pointer.</p>

<a name="ERRORS: See: Judy_3.htm#ERRORS"></a>
<h2>ERRORS: See: Judy_3.htm#ERRORS</h2>


<a name="EXAMPLE"></a>
<h2>EXAMPLE</h2>


<p style="margin-left:11%; margin-top: 1em">Read a series
of index/value pairs from the standard input, store in a
JudyL array, and then print out in sorted order.</p>

<p style="margin-left:11%; margin-top: 1em"><big>#include
&lt;stdio.h&gt; <br>
#include &lt;Judy.h&gt;</big></p>

<p style="margin-left:11%; margin-top: 1em">Word_t Index;
// array index <br>
Word_t Value; // array element value <br>
Word_t * PValue; // pointer to array element value <br>
int Rc_int; // return code</p>

<p style="margin-left:11%; margin-top: 1em">Pvoid_t
PJLArray = (Pvoid_t) NULL; // initialize JudyL array</p>

<p style="margin-left:11%; margin-top: 1em">while
(scanf(&quot;%lu %lu&quot;, &amp;Index, &amp;Value)) <br>
{ <br>
JLI(PValue, PJLArray, Index); <br>
If (PValue == PJERR) goto process_malloc_failure; <br>
*PValue = Value; // store new value <br>
} <br>
// Next, visit all the stored indexes in sorted order, first
ascending, <br>
// then descending, and delete each index during the
descending pass.</p>

<p style="margin-left:11%; margin-top: 1em">Index = 0; <br>
JLF(PValue, PJLArray, Index); <br>
while (PValue != NULL) <br>
{ <br>
printf(&quot;%lu %lu\n&quot;, Index, *PValue)); <br>
JLN(PValue, PJLArray, Index); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Index = -1;
<br>
JLL(PValue, PJLArray, Index); <br>
while (PValue != NULL) <br>
{ <br>
printf(&quot;%lu %lu\n&quot;, Index, *PValue));</p>

<p style="margin-left:11%; margin-top: 1em">JLD(Rc_int,
PJLArray, Index); <br>
if (Rc_int == JERR) goto process_malloc_failure;</p>

<p style="margin-left:11%; margin-top: 1em">JLP(PValue,
PJLArray, Index); <br>
}</p>

<a name="AUTHOR"></a>
<h2>AUTHOR</h2>


<p style="margin-left:11%; margin-top: 1em">Judy was
invented by Doug Baskins and implemented by
Hewlett-Packard.</p>

<a name="SEE ALSO"></a>
<h2>SEE ALSO</h2>



<p style="margin-left:11%; margin-top: 1em"><i>Judy</i>(3),
<i>Judy1</i>(3), <i>JudySL</i>(3), <i>JudyHS</i>(3), <i><br>
malloc()</i>, <i><br>
http://judy.sourceforge.net</i>, for more information and
Application Notes.</p>
<hr>
</body>
</html>
