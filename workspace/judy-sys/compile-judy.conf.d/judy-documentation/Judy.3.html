<!-- Creator     : groff version 1.19.2 -->
<!-- CreationDate: Wed Jul 19 12:44:43 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p     { margin-top: 0; margin-bottom: 0; }
       pre   { margin-top: 0; margin-bottom: 0; }
       table { margin-top: 0; margin-bottom: 0; }
</style>
<title>Judy</title>

</head>
<body>

<h1 align=center>Judy</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#A 10 MINUTE TECHNICAL DESCRIPTION">A 10 MINUTE TECHNICAL DESCRIPTION</a><br>
<a href="#A 3 HOUR TECHNICAL DESCRIPTION (out of date and a bit corny)">A 3 HOUR TECHNICAL DESCRIPTION (out of date and a bit corny)</a><br>
<a href="#DOWNLOADS">DOWNLOADS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#FILES">FILES</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#1) Default Error Handling Method">1) Default Error Handling Method</a><br>
<a href="#2) Disable Macro Error Handling">2) Disable Macro Error Handling</a><br>
<a href="#3) User-Specified JUDYERROR() Macro Method">3) User-Specified JUDYERROR() Macro Method</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<a name="NAME"></a>
<h2>NAME</h2>


<p style="margin-left:11%; margin-top: 1em">Judy arrays - C
library functions for creating and accessing dynamic
arrays</p>

<a name="SYNOPSIS"></a>
<h2>SYNOPSIS</h2>



<p style="margin-left:11%; margin-top: 1em"><b><big>Judy1</big></b>
<big>- maps an <b>Index</b> (word) to a <b>bit <br>
JudyL</b> - maps an <b>Index</b> (word) to a <b>Value</b>
(word/pointer) <b><br>
JudySL</b> - maps an <b>Index</b> (null terminated string)
to a <b>Value <br>
JudyHS</b> - maps an <b>Index</b> (array-of-bytes) of
<b>Length</b> to a <b>Value</b></big></p>

<a name="DESCRIPTION"></a>
<h2>DESCRIPTION</h2>


<p style="margin-left:11%; margin-top: 1em">The Judy family
of functions supports fully dynamic arrays. These arrays may
be indexed by a 32- or 64-bit word (depending on processor
word size), a null terminated string or an array-of-bytes
plus length. A dynamic array (sparsely populated) can also
be thought of as a <i>mapping function</i> or <i>associative
memory</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A <b>Word_t</b>
is a <i>typedef unsigned long int</i> in <b>Judy.h</b> and
must be the same size as <i>sizeof(void *)</i> I.E. a
pointer.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Judy1</b>
functions: <b>Index</b> is a <b>Word_t</b> and <b>Value</b>
is just a <b>bit</b> or simply a flag that <b>Index</b> is
present or missing from the array. This can be thought of as
a huge bitmap.</p>

<p style="margin-left:11%; margin-top: 1em"><b>JudyL</b>
functions: <b>Index</b> is a <b>Word_t</b> and <b>Value</b>
is a <b>Word_t</b>. This makes <b>JudyL</b> a pure
word-to-word/pointer mapper. <b>JudySL</b> and <b>JudyHL</b>
are based on this property of <b>JudyL</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>JudySL</b>
functions: <b>Index</b> is a null-terminated string and
<b>Value</b> is a <b>Word_t</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>JudyHS</b>
functions: <b>Index</b> is an array-of-bytes of length:
<b>Length</b>. <b>Value</b> is a <b>Word_t</b>. This new
addition (May 2004) to Judy is a hybird using the best
features of hashing and Judy methods. The author believes
<b>JudyHS</b> is a good replacement for a hashing method
when resizing the hash table is done during population
growth. A correctly tuned hash method with a <b>static</b>
hash table size and population is unbeatable for speed.
However, <b>JudyHS</b> will perform better than a hashing
method with smaller and larger populations than the optimum
hash table size. <b>JudyHS</b> does not have a degenerate
performance case where knowledge of the hash algorithm can
be exploited. (I.E. JudyHS does not use a linked list to
handle hash collisions, it uses a tree of <b>JudyL</b>
arrays and a virtual hash table size of 4 billion).</p>

<p style="margin-left:11%; margin-top: 1em">Judy arrays are
both <b>speed-</b> and <b>memory-efficient</b>, with no
tuning or configuration required, across a wide range of
index set types (sequential, periodic, clustered, random).
Judy&rsquo;s speed and memory usage are typically better
than other data storage models such as skiplists, linked
lists, binary, ternary, b-trees, or even hashing, and
improves with very large data sets.</p>

<p style="margin-left:11%; margin-top: 1em">A Judy array is
created merely by defining a null pointer and then storing
(inserting) the first element into the array under that
pointer. The memory used by a Judy array is nearly
proportional to the population (number of elements).</p>

<p style="margin-left:11%; margin-top: 1em">Judy has two
Application Program Interfaces (APIs): a C macro interface,
and a function call interface. Because the macro forms are
sometimes faster and have a simpler error handling interface
than the equivalent functions, they are the preferred way of
using the Judy functions.</p>

<p style="margin-left:11%; margin-top: 1em">Since an
initial (empty) Judy array is represented by a null pointer,
it is possible to construct an array of Judy arrays. In
other words, a Judy array&rsquo;s <b>Values</b> (except
Judy1) can be pointers to other Judy arrays. This makes it
very simple to construct an array with an arbitrary number
of dimensions or <b>Index</b> sizes. (JudySL and JudyHS are
implemented using JudyL this way).</p>

<a name="A 10 MINUTE TECHNICAL DESCRIPTION"></a>
<h2>A 10 MINUTE TECHNICAL DESCRIPTION</h2>


<p style="margin-left:11%; margin-top: 1em">may be found at
<i>http://judy.sourceforge.net/downloads/10minutes.htm</i></p>

<a name="A 3 HOUR TECHNICAL DESCRIPTION (out of date and a bit corny)"></a>
<h2>A 3 HOUR TECHNICAL DESCRIPTION (out of date and a bit corny)</h2>


<p style="margin-left:11%; margin-top: 1em">may be found at
<i>http://judy.sourceforge.net/application/shop_interm.pdf</i></p>

<a name="DOWNLOADS"></a>
<h2>DOWNLOADS</h2>


<p style="margin-left:11%; margin-top: 1em">Judy source
downloads are available at
<i>http://sourceforge.net/projects/judy</i> <br>
Binarys may be built and installed in a minute or two after
downloading</p>

<p style="margin-left:11%; margin-top: 1em">For versions
including more platforms and/or new features see:
<i>http://judy.sourceforge.net/downloads/</i></p>

<a name="AUTHOR"></a>
<h2>AUTHOR</h2>


<p style="margin-left:11%; margin-top: 1em">Judy was
invented by Doug Baskins (dougbaskins .AT, yahoo.com) and
implemented by Hewlett-Packard. (Note: Judy is named for the
inventor&rsquo;s sister, after discarding many proposed
names.)</p>

<a name="FILES"></a>
<h2>FILES</h2>


<p style="margin-left:11%; margin-top: 1em">Locations of
interest include: <i><br>
http://sourceforge.net/projects/judy</i> -- project
downloads <i><br>
file:/usr/share/doc/Judy/</i> -- for HTML version of man
pages. <br>
/usr/share/doc/Judy/demo/ -- demonstration program source
files. <br>
The author attempted to write interesting application notes
using advanced features of Judy. They may be found at
<i>&quot;http://judy.sourceforge.net/application/</i> (Some
may be out of date).</p>

<a name="ERRORS"></a>
<h2>ERRORS</h2>


<p style="margin-left:11%; margin-top: 1em">A lot of
thought (and time) went into making error handling in Judy
simple, while maintaining flexibility and capability. Error
handling is a very boring subject even to write about. So
read this short section and use the recommended second
method. It generates the fastest code, uses the least amount
of memory and requires you to write extra code only for
insert/deletes functions. Also it is compatible with the
other two methods. This method is for production code that
may want to handle <i>malloc()</i> fails differently than
the Judy default. If the Judy default method of handling
<i>malloc()</i> fails are OK, then use the first method.</p>

<p style="margin-left:11%; margin-top: 1em">There are
<i>two (2)</i> categories of Judy error returns, (or for any
dynamic ADT):</p>

<p style="margin-left:11%; margin-top: 1em">1) User
programming errors (bugs) such as memory corruption or
invalid pointers. <br>
2) Out-of-memory (<i>malloc()</i> failure) with
<b>I</b>nsert (<b>S</b>et) or <b>D</b>elete (<b>U</b>nset)
when modifying a Judy array. Not all calls to insert and
delete call <i>malloc()</i>, so they may succeed even when a
call to <i>malloc()</i> would fail.</p>

<p style="margin-left:11%; margin-top: 1em">There are
roughly <i>three (3)</i> methods of handling errors when
using the macros:</p>

<a name="1) Default Error Handling Method"></a>
<h2>1) Default Error Handling Method</h2>


<p style="margin-left:11%; margin-top: 1em">The default is
to print error messages to <b>stderr</b>, for example:</p>

<p style="margin-left:11%; margin-top: 1em"><big>File
&rsquo;YourCfile.c&rsquo;, line 1234: JudyLIns(), JU_ERRNO_*
== 2, ID == 321</big> <br>
This indicates that an error occurred in the
<b>JudyLIns()</b> function at line 321. Line 1234 is the
line in &rsquo;YourCfile.c&rsquo; where the <b>JLI()</b>
call failed. JU_ERRNO_* == 2 is equal to JU_ERRNO_NOMEM (as
defined in the <b>Judy.h</b> file). The ID number indicates
the source line number in the function where the error
originated. Your program then terminates with an
<i>exit(1);</i>. By default, both categories of Judy error
returns are printed this way. (The &rsquo;ID == 321&rsquo;
is for die hards that want more detail or for debugging Judy
itself.)</p>

<a name="2) Disable Macro Error Handling"></a>
<h2>2) Disable Macro Error Handling</h2>


<p style="margin-left:11%; margin-top: 1em">When your
program is &quot;bug free&quot;, the only errors returned
should be <i>malloc()</i> failures. Therefore all error
returns can be treated as a <i>malloc()</i> failure. By
using the below <b>#define</b>, all error testing and
printing is turned off. Additional code needs to be added to
the code that can have <i>malloc()</i> failures. Judy was
designed to leave the same data in the array before the call
if a <i>malloc()</i> fail occurs. (During testing of Judy,
we found very few <i>malloc()</i>/OS&rsquo;s that were bug
free after a <i>malloc()</i> failure. Sometimes it took
weeks to discover because most systems go into a paging
frenzy before running out of memory).</p>

<p style="margin-left:11%; margin-top: 1em"><big>#define
JUDYERROR_NOTEST 1</big> <br>
(in your program code), or</p>

<p style="margin-left:11%; margin-top: 1em"><big>cc
-DJUDYERROR_NOTEST <i>sourcefile</i> -lJudy</big> <br>
(on your command line).</p>

<p style="margin-left:11%; margin-top: 1em"><big>// This is
an example of how to program using method two (2).</big></p>

<p style="margin-left:11%; margin-top: 1em">JLI(PValue,
PLArray, Index); <br>
if (PValue == PJERR) goto out_of_memory_handling;</p>

<p style="margin-left:11%; margin-top: 1em">JLD(RC_int,
PLArray, Index); <br>
if (RC_int == JERR) goto out_of_memory_handling;</p>

<p style="margin-left:11%; margin-top: 1em">J1S(RC_int,
P1Array, Index); <br>
if (RC_int == JERR) goto out_of_memory_handling;</p>

<p style="margin-left:11%; margin-top: 1em">J1U(RC_int,
P1Array, Index); <br>
if (RC_int == JERR) goto out_of_memory_handling;</p>

<p style="margin-left:11%; margin-top: 1em">Note: Without
&rsquo;JUDYERROR_NOTEST&rsquo; defined, the &rsquo;goto
out_of_memory_handling&rsquo; will never be executed and
will be optimized out by the compiler. The default method
will be used -- Macro will print error information if an
error occurs as explained above.</p>

<p style="margin-left:11%; margin-top: 1em">With
&rsquo;JUDYERROR_NOTEST&rsquo; defined, the &rsquo;goto
out_of_memory_handling&rsquo; will be executed when an error
occurs -- which should only happen when <i>malloc()</i>
fails.</p>

<a name="3) User-Specified JUDYERROR() Macro Method"></a>
<h2>3) User-Specified JUDYERROR() Macro Method</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>JUDYERROR()</b> macro (in <b>Judy.h</b>) provides
flexibility for handling error returns as needed to suit
your program while still using the Judy array macros instead
of function calls. You can use a different
<b>JUDYERROR()</b> macro to suit your needs. The following
example is a possible alternative to the default. It is used
to distinguish between the two types of errors (described
above), and explicitly test for the remaining JU_ERRNO_NOMEM
errors possible in your program.</p>

<p style="margin-left:11%; margin-top: 1em"><big>// This is
an example of Judy macro API to continue when out of memory
<br>
// and print and exit(1) when any other error
occurs.</big></p>

<p style="margin-left:11%; margin-top: 1em">#ifndef
JUDYERROR_NOTEST <br>
#include &lt;stdio.h&gt; // needed for fprintf()</p>

<p style="margin-left:11%; margin-top: 1em">// This is the
macro that the Judy macro APIs use for return codes of
-1:</p>

<p style="margin-left:11%; margin-top: 1em">#define
JUDYERROR(CallerFile, CallerLine, JudyFunc, JudyErrno,
JudyErrID) \ <br>
{ \ <br>
if ((JudyErrno) != JU_ERRNO_NOMEM) /* ! a malloc() failure
*/ \ <br>
{ \ <br>
(void) fprintf(stderr, &quot;File &rsquo;%s&rsquo;, line %d:
%s(), &quot; \ <br>
&quot;JU_ERRNO_* == %d, ID == %d\n&quot;, \ <br>
CallerFile, CallerLine, \ <br>
JudyFunc, JudyErrno, JudyErrID); \ <br>
exit(1); \ <br>
} \ <br>
} <br>
#endif // JUDYERROR_NOTEST not defined <br>
This error handling macro must be included before the
<b>#include &lt;Judy.h&gt;</b> statement in your
program.</p>

<a name="SEE ALSO"></a>
<h2>SEE ALSO</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Judy1(3)</b>,
<b>JudyL(3)</b>, <b>JudySL(3)</b>, <b>JudyHS(3)</b></p>
<hr>
</body>
</html>
